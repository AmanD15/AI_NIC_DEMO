//
// 	   There's only one freeQ accessed by both processor and NIC,
//	   so it needs to first get a lock before push/pop and also unlock it after
//	   This locking/unlocking has been done explicitly by the NIC in receive/transmit engine.
//
// 	   But, queue_status_register update is being done implicitly by both processor and NIC
//	   after every push/pop operations.
//

//
// NIC pops the buffer pointer from only freeQ and TxQ by providing 
// queue_type and server_id
//
// After popping buffer pointer from the queue it calls accessRegister module
// to updates the respective server's queue_status_register
//
// Arguments:	
//		queue_type : 	can be FREEQUEUE or TXQUEUE for pop by NIC
//		server_id  : 	can only be SERVER_0 for FREEQUEUE, but
//				can be any of 4 servers SERVER_0, SERVER_1, SERVER_2 or SERVER_3 for TXQUEUE
//
// Return value: 
//		q_rdata    :	buffer pointers popped from FREEQUEUE or any of the TXQUEUEs
//		status	   :	returns <no. of entries> <push_status> <pop_status>
//				pop_status == 0 is success.
//
$module [popFromQueue]
	$in (queue_type: $uint<2> server_id : $uint<4>) 
	$out (q_rdata: $uint<32> status: $uint<32>)
$is
{
	$volatile FreeQ   := (queue_type == FREEQUEUE)
	$volatile TxQ     := (queue_type == TXQUEUE)
	
	$volatile server_0 := (server_id == SERVER_0)
	$volatile server_1 := (server_id == SERVER_1)
	$volatile server_2 := (server_id == SERVER_2)
	$volatile server_3 := (server_id == SERVER_3)
	
	$volatile wdata := $zero<32>

	// Pop from TxQ
	$guard (TxQ)
		$call exec_transmit_queue_command (server_id POP wdata) (tx_nentries tx_push_status tx_pop_status txq_rdata)
		
	// Pop from freeQ
	$guard (FreeQ)
		$call exec_free_queue_command (server_id POP wdata) (f_nentries f_push_status f_pop_status fq_rdata)
	
	// queue_status_register index calculation from queue_type and server_id
	$volatile status_index := 
			($excmux 
				FreeQ				P_FREE_QUEUE_STATUS_INDEX
				TxQ     ($excmux 
						server_0 	P_TX_QUEUE_0_STATUS_INDEX
						server_1 	P_TX_QUEUE_0_STATUS_INDEX
						server_2 	P_TX_QUEUE_0_STATUS_INDEX
						server_3 	P_TX_QUEUE_0_STATUS_INDEX))
						
	$volatile status := ($excmux
				TxQ	($concat tx_nentries tx_push_status tx_pop_status)
				FreeQ	($concat f_nentries  f_push_status  f_pop_status))
	
	// returns popped value back to the caller		
	q_rdata := ($excmux
			TxQ	txq_rdata
			FreeQ	fq_rdata)
	
	// update queue_status_register					
	$call accessRegister (WRITEMEM _hF status_index status) (ign_rsp)
}


//
// NIC pushes the buffer pointer to only RxQ and freeQ by providing 
// queue_type and server_id.
//
// After pushing buffer pointer to the queue it calls accessRegister module
// to updates the respective server's queue_status_register
//
// Arguments:	
//		queue_type : 	can be FREEQUEUE or RXQUEUE for push by NIC
//		server_id  : 	can only be SERVER_0 for FREEQUEUE, but
//				can be any of 4 servers SERVER_0, SERVER_1, SERVER_2 or SERVER_3 for RXQUEUE
//		q_wdata    :	buffer pointers to be pushed into FREEQUEUE or any of the RXQUEUEs
//
// Return value: 
//		status	   :	returns <no. of entries> <push_status> <pop_status>
//				push_status == 0 is success.
//
$module [pushIntoQueue] 
	$in  (queue_type: $uint<2> server_id: $uint<4> q_wdata: $uint<32>) 
	$out (status: $uint<32>)
$is
{
	$volatile FreeQ   := (queue_type == FREEQUEUE)
	$volatile RxQ     := (queue_type == RXQUEUE)
	
	$volatile server_0 := (server_id == SERVER_0)
	$volatile server_1 := (server_id == SERVER_1)
	$volatile server_2 := (server_id == SERVER_2)
	$volatile server_3 := (server_id == SERVER_3)

	// Push into RxQ
	$guard (RxQ)
		$call exec_receive_queue_command (server_id PUSH q_wdata) (rx_nentries rx_push_status rx_pop_status rx_ignr)
	
	// Push into freeQ
	$guard (FreeQ)
		$call exec_free_queue_command (server_id PUSH q_wdata) (f_nentries f_push_status f_pop_status f_ignf)
	
	// queue_status_register index calculation from queue_type and server_id
	$volatile status_index := 
			($excmux 
				FreeQ				P_FREE_QUEUE_STATUS_INDEX
				RxQ    ($excmux 
						server_0	P_RX_QUEUE_0_STATUS_INDEX
						server_1 	P_RX_QUEUE_0_STATUS_INDEX
						server_2 	P_RX_QUEUE_0_STATUS_INDEX
						server_3 	P_RX_QUEUE_0_STATUS_INDEX))
		
	$volatile status := ($excmux
				RxQ	($concat rx_nentries rx_push_status rx_pop_status)
				FreeQ	($concat f_nentries  f_push_status  f_pop_status))

	// update queue_status_register					
	$call accessRegister (WRITEMEM _hF status_index status) (ign_rsp)
}


//
// For debug purpose only through debug_queue pipes
//
$module [queueTestDaemon] $in () $out () $is
{
	$branchblock[loop] 
	{
		$merge $entry loopback $endmerge

		cmd := debug_queue_command 
		$volatile $split (cmd 1 25 2 4 32) (rwbar u15 queue_type server_id val)
		
		$guard (~rwbar)
			$call pushIntoQueue (queue_type server_id val) (push_status)
		// push_ok == 0 is success, i.e., pushed buffer pointer from queue
		$volatile push_ok := ($bitreduce | ($slice push_status 15 8))
			
		$guard (rwbar)
			$call popFromQueue (queue_type server_id) (pop_val pop_status)
		// pop_ok == 0 is success, i.e., popped buffer pointer from queue
		$volatile pop_ok := ($bitreduce | ($slice pop_status 7 0))
		
		// not_ok == 0 is ok
		$volatile not_ok := ($mux rwbar pop_ok push_ok)
		$volatile ret_data := ($mux rwbar ($bitcast ($uint<63>) pop_val) $zero<63>)
		$volatile result := ($concat not_ok ret_data)

		debug_queue_response := result

		$place [loopback]
	}

}
