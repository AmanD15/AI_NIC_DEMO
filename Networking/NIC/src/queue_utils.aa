//
// This are super-critical routines, which mirror the cortos2 queue
// implementation.
//
//---------------------------------------------------------
//Cortos queue data structure.
//---------------------------------------------------------
//typedef struct _CortosQueueHeader {
  //uint32_t totalMsgs; // current total messages   +0
  //uint32_t readIndex;				    +4
  //uint32_t writeIndex;			    +8
  //uint32_t length;				    +12
  //uint32_t msgSizeInBytes;			    +16
  //uint8_t *lock;				    +20
  //uint8_t *bget_addr;				    +24
  // if misc == 1, then assume single writer and single reader and don't use locks
  //uint32_t misc;				    +28
//} CortosQueueHeader;

$constant READMEM  : $uint<1> := 1
$constant WRITEMEM : $uint<1> := 0
$constant LOCKMEM  : $uint<1> := 1
$constant UNLOCKMEM: $uint<1> := 0

//
// qptr is aligned to quad-word boundary.
//
$module [accessQueueTotalMsgs] 
	$in (rwbar: $uint<1> qptr: $uint<36> wdata: $uint<32>) $out (rdata: $uint<32) $is
{
	$call accessMemory (UNLOCKMEM rwbar _hF0 qptr ($concat wdata $zero<32>)) (dword)
	$volatile rdata := ($slice  dword 63 32)
}
$module [accessQueueReadIndex] 
	$in (rwbar: $uint<1> qptr: $uint<36> wdata: $uint<32>) $out (rdata: $uint<32) $is
{
	$call accessMemory (UNLOCKMEM rwbar _h0F qptr ($concat $zero<32> wdata)) (dword)
	$volatile rdata := ($slice  dword 31 0)
}
$module [accessQueueWriteIndex] 
	$in (rwbar: $uint<1> qptr: $uint<36> wdata: $uint<32>) $out (rdata: $uint<32) $is
{
	$call accessMemory (UNLOCKMEM rwbar _hF0 (qptr + 8) ($concat wdata $zero<32>)) (dword)
	$volatile rdata := ($slice  dword 63 32)
}
$module [accessQueueLength] 
	$in (rwbar: $uint<1> qptr: $uint<36> wdata: $uint<32>) $out (rdata: $uint<32) $is
{
	$call accessMemory (UNLOCKMEM rwbar _h0F (qptr + 8) ($concat $zero<32> wdata)) (dword)
	$volatile rdata := ($slice  dword 31 0)
}
$module [accessQueueMsgSizeInBytes] 
	$in (rwbar: $uint<1> qptr: $uint<36> wdata: $uint<32>) $out (rdata: $uint<32) $is
{
	$call accessMemory (UNLOCKMEM rwbar _hF0 (qptr + 16) ($concat wdata $zero<32>)) (dword)
	$volatile rdata := ($slice  dword 63 32)
}
$module [accessQueueLockPointer] 
	$in (rwbar: $uint<1> qptr: $uint<36> wdata: $uint<32>) $out (rdata: $uint<32) $is
{
	$call accessMemory (UNLOCKMEM rwbar _h0F (qptr + 16) ($concat $zero<32> wdata)) (dword)
	$volatile rdata := ($slice  dword 31 0)
}
$module [accessQueueBgetAddr] 
	$in (rwbar: $uint<1> qptr: $uint<36> wdata: $uint<32>) $out (rdata: $uint<32) $is
{
	$call accessMemory (UNLOCKMEM rwbar _hF0 (qptr + 24) ($concat wdata $zero<32>)) (dword)
	$volatile rdata := ($slice  dword 63 32)
}
$module [accessQueueMisc] 
	$in (rwbar: $uint<1> qptr: $uint<36> wdata: $uint<32>) $out (rdata: $uint<32) $is
{
	$call accessMemory (UNLOCKMEM rwbar _h0F (qptr + 24) ($concat $zero<32> wdata)) (dword)
	$volatile rdata := ($slice  dword 31 0)
}
$module [accessQueueMisc] 
	$in (rwbar: $uint<1> qptr: $uint<36> wdata: $uint<32>) $out (rdata: $uint<32) $is
{
	$call accessMemory (UNLOCKMEM rwbar _h0F (qptr + 24) ($concat $zero<32> wdata)) (dword)
	$volatile rdata := ($slice  dword 31 0)
}
$module [accessQueueElement] 
	$in (rwbar: $uint<1> qptr: $uint<36> index: $uint<32> wdata: $uint<32>) 
		$out (rdata: $uint<32) $is
{
	$call accessQueueBgetAddr (READMEM qptr $zero<32>) (base_addr)

	// base + (4*index)
	$volatile addr := (base_addr + ($concat $zero<1> index $zero<2>))

	// set bottom bit of addr to 0 for u64 access.
	$volatile addr_u64 := ($concat ($slice addr 35 1) $zero<1>)

	$volatile low_word := (index [] 1)
	$volatile bmask    := ($mux low_word _h0F _hF0)
	$volatile wdata64  := ($mux low_word ($concat $zero<32> wdata) ($concat wdata $zero<32>))

	$call accessMemory (UNLOCKMEM rwbar bmask addr_u64 wdata64) (dword)
	rdata := ($mux low_word  ($slice dword 31 0) ($slice dword 63 32))
}


//
// Utilities
//    Pop a uint32_t from the queue.  Return status = 0 on success.
//
//	1. acquire lock
// 	2. Get read write indexs
//	3. calculate next read index
//	4. read queue data
//	5. update queue indexes
//	6. release lock
$module [popFromQueue]
	$in (lock : $uint<1> q_base_address : $uint<36>) $out (q_r_data: $uint<32> status: $uint<1>)
$is
{
	// check if misc is 1,
	// if 1 check if total_msgs is 0
	//  if yes wait for total_msgs to be 1
	//   when 1 pop data
	// if misc is 0 
	// follow old method
	$call accessQueueMisc (READMEM q_base_address $zero<32>) (misc)

	//$branchblock[loop]
	//{
	//	$merge $entry loopback $endmerge
	//
	//	$call getTotalMessages(q_base_address) (total_msgsI)
	//	$volatile q_emptyI := (total_msgsI == 0)
	//
	//	$volatile misc_one := (misc == 1)
	//	$if(misc_one & q_emptyI) $then
	//		$place[loopback]
	//	$endif
	//}
	$volatile lock_n  := (misc == $zero<32>)

	$guard (lock_n) $call acquireLock(q_base_address) (m_ok)
	$barrier
	
	$call getQueuePointers (q_base_address) (write_index read_index)
	$volatile q_empty := (write_index == read_index)

	$call getQueueLength(q_base_address) (Queue_Length)
	$call getTotalMessages(q_base_address) (total_msgs)

	//$volatile q_empty := (total_msgs == 0)
	$volatile round_off := (read_index == (Queue_Length - 1))
	$volatile next_ri := ($mux round_off 0 (read_index + 1))
	
	$guard (~q_empty) $call getQueueElement (q_base_address read_index) (q_r_data)
	$guard (~q_empty) $call setQueuePointers (q_base_address write_index next_ri) ()
	$guard (~q_empty) $call updateTotalMessages (q_base_address (total_msgs - $one<32>)) ()
	$rreport(popFromQueue pop_data q_base_address q_r_data q_empty write_index read_index next_ri)

	$barrier
	$guard(lock_n) $call releaseLock (q_base_address) ()
	status := q_empty // 0 = success, 1 = Fail
	
}

//
//
// Utilities
//    push a uint32_t into the queue.  Return status = 0 on success.
// 
//	1. acquire lock
// 	2. Get read write indexs
//	3. calculate next write index
//	4. write data to queue
//	5. update queue indexes
//	6. release lock
//
$module [pushIntoQueue] 
	$in  (lock : $uint<1> q_base_address : $uint<36> q_w_data: $uint<32>) $out (status: $uint<1>)
$is
{
	// check if misc is 1,
	// if 1 check if total_msgs is 1
	//  if yes wait for total_msgs to be 0
	//   when 0 push data
	// if misc is 0 
	// follow old method

	$call accessMemory ($zero<1> $one<1>  (~$zero<8>)
				 (q_base_address + 24 ) $zero<64>) (ba_and_misc)
	$volatile misc := ($slice ba_and_misc 31 0)

	//$branchblock[loop]
	//{
	//	$merge $entry loopback $endmerge
	//
	//	$call getTotalMessages(q_base_address) (total_msgsI)
	//	$volatile q_emptyI := (total_msgsI == 0)
	//
	//	$volatile misc_one := (misc == 1) // if misc = 1 misc_one = 1
	//	$if(misc_one & (~q_emptyI)) $then
	//		$place[loopback]
	//	$endif
	//}
	$volatile lock_n  := (misc == $zero<32>)

	$guard (lock_n) $call acquireLock (q_base_address) (m_ok) 
	$barrier

	$rreport(pushIntoQueue pushing_to_queue q_w_data q_base_address)
	$call getQueuePointers (q_base_address) (write_index read_index)
	
	$call getQueueLength(q_base_address) (Queue_Length)
	$call getTotalMessages(q_base_address) (total_msgs)
	$volatile round_off := (write_index == (Queue_Length - 1))
	$volatile next_wi := ($mux round_off 0 (write_index + 1))
	
	$volatile q_full := (next_wi == read_index)
	$rreport(pushIntoQueue pushing_to_queue q_w_data write_index read_index next_wi q_full)
	$guard (~q_full) $call setQueueElement  (q_base_address write_index q_w_data) ()
	$guard (~q_full) $call setQueuePointers (q_base_address next_wi read_index) ()
	$guard (~q_full) $call updateTotalMessages (q_base_address (total_msgs + $one<32>)) ()


	$barrier
	$guard (lock_n) $call releaseLock (q_base_address) ()
	status := (~q_full)
}

//
// to get queue length
//
$module [getQueueLength]
	$in (q_base_address : $uint<36>) $out (queue_length : $uint<32>)
$is
{
	$call accessQueueLength (READMEM q_base_address $zero<32>) (queue_length)
}

//
// lock read  modify write (aka LDSTUB), spin till lock acquired.
//
//	1. read lock_pointer(address) from queue(locked read)
//	2. read data at lock_pointer(address)
//	3. get 8bit lock data from 64bit read data
//	4. if lock = FF -> keep checking (release mem lock and acquire again)
//	     else set lock(queue) = FF aalong with releasing memory lock
$module [acquireLock] $in (q_base_address: $uint<36>) $out (m_ok: $uint<1>) 
$is
{
	// get the pointer to the lock.
	$call accessQueueLockPointer (READMEM q_base_address $zero<32>) (lock_address_pointer)	

	$branchblock[loop] {


		$merge $entry loopback $endmerge
		
		// read the lock (note that this is a locked read)
		$call accessMemoryByte (LOCKMEM READMEM lock_address_pointer $zero<8>) (lock_val)

		$if (lock_val == (~$zero<8>)) $then
			// unlock memory path
			$call accessMemoryByte 
				(UNLOCKMEM READMEM lock_address_pointer $zero<8>) (ign_rval)
			$place [loopback]
		$endif

		// write 0xFF into lock location..  (also unlock the memory path).
		$call accessMemoryByte (UNLOCKMEM WRITEMEM lock_address_pointer _hFF) (ignore)
	}

	m_ok := $one<1>
}


//
// set lock to 00000000 in queue.
//
//	1. read lock pointer from queue
//	2. create bmask(which will only update corresponding locks bits)
//	3. write 0 to lock address with bamsk.
$module [releaseLock] $in (q_base_address: $uint<36>) $out () $is
{
	// get the pointer to the lock.
	$call accessQueueLockPointer 
		(READMEM q_base_address $zero<32>) (lock_address_pointer)	
		
	// write 0x0 into lock location..  (also unlock the memory path).
	$call accessMemoryByte 
		(UNLOCKMEM WRITEMEM lock_address_pointer 0) (ignore)
}

	

//
// get wp, rp pair.
//
$module [getQueuePointers] $in (q_base_address: $uint<36>)
		$out (wp rp: $uint<32>) $is
{
    $call accessQueueReadIndex  (READMEM q_base_address $zero<32>) (rp)
    $call accessQueueWriteIndex (READMEM q_base_address $zero<32>) (wp)
}

//
// set wp, rp pair.
//
$module [setQueuePointers] $in (q_base_address: $uint<36> wp rp: $uint<32>) $out ()  $is
{

    $rreport(setQueuePointers set q_base_address wp rp)

    $call accessQueueReadIndex  (WRITEMEM q_base_address $zero<32>) (rp)
    $call accessQueueWriteIndex (WRITEMEM q_base_address $zero<32>) (wp)
}

	
//
// get element pointed to by read-index
// inside queue.
//
$module  [getQueueElement]
	$in (q_base_address: $uint<36> read_index: $uint<32>) 
	$out (q_r_data : $uint<32>)
$is
{
	$call accessQueueBgetAddr (READMEM q_base_addr $zero<32>) (buf_base_addr)
	$call accessQueueElement  (READMEM base_addr read_index $zero<32>) (q_r_data)
}

//
// set queue element pointed to by write
// index.
//
$module  [setQueueElement]
	$in (q_base_address: $uint<36> write_index: $uint<32> q_w_data : $uint<32>)
	$out () 
$is
{
	$call accessQueueBgetAddr (READMEM q_base_addr $zero<32>) (buf_base_addr)
	$call accessQueueElement  (WRITEMEM base_addr write_index $zero<32>) (q_r_data)
}

$module [getTotalMessages]
	$in (q_base_address : $uint<36>)
	$out(total_msgs : $uint<32>)
$is
{	
	$call accessQueueTotalMsgs (READMEM q_base_address $zero<32>) (total_msgs)
}

$module [updateTotalMessages]
	$in (q_base_address : $uint<36> updated_total_msgs : $uint<32>)
	$out()
$is
{	
	$call accessQueueTotalMsgs (WRITEMEM q_base_address $zero<32> updated_total_msgs) (ignore)
}

