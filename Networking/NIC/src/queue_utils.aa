//
// This are super-critical routines, which mirror the cortos2 queue
// implementation.
//
//---------------------------------------------------------
//Cortos queue data structure.
//---------------------------------------------------------
//typedef struct _CortosQueueHeader {
  //uint32_t totalMsgs; // current total messages   +0
  //uint32_t readIndex;				    +4
  //uint32_t writeIndex;			    +8
  //uint32_t length;				    +12
  //uint32_t msgSizeInBytes;			    +16
  //uint8_t *lock;				    +20
  //uint8_t *bget_addr;				    +24
  // if misc == 1, then assume single writer and single reader and don't use locks
  //uint32_t misc;				    +28
//} CortosQueueHeader;

$volatile $module [getBaseIndex] 
	$in (queue_type: $uint<2> server_id: $uint<8>) $out (base_index : $uint<8>) $is
{
	base_index :=  ($mux 
				(queue_type == FREEQUEUE) P_FREE_QUEUE_REGISTER_BASE_INDEX 
				(($mux (queue_type == TXQUEUE) P_TX_QUEUE_REGISTER_BASE_INDEX P_RX_QUEUE_REGISTER_BASE_INDEX) + 
					(server_id * 8)))
}

//
// queue address, lock address and buffer address are stored in the
// NIC by software.  These are 36-bit PHYSICAL addresses!
//

// Get queue pointer physical address
$module [getQueuePointer] $in (queue_type: $uint<2> server_id: $uint<8>) $out (qptr : $uint<36>) $is
{
	base_idx := ($call getBaseIndex ( queue_type server_id))
	$call accessRegister (READMEM _hF base_idx $zero<32>) (qptr_h)
	$call accessRegister (READMEM _hF (base_idx+1) $zero<32>) (qptr_l)

	qptr := ($concat ($slice qptr_h 3 0) qptr_l)

	$attribute input_buffering 0
	$attribute output_buffering 0
}


// get queue lock pointer physical address
$module [getQueueLockPointer] $in (queue_type: $uint<2> server_id: $uint<8>) $out (qptr : $uint<36>) $is
{
	base_idx := ($call getBaseIndex ( queue_type server_id))

	$call accessRegister (READMEM _hF (base_idx+2) $zero<32>) (qptr_h)
	$call accessRegister (READMEM _hF (base_idx+3) $zero<32>) (qptr_l)

	qptr := ($concat ($slice qptr_h 3 0) qptr_l)

	$attribute input_buffering 0
	$attribute output_buffering 0
}

// get queue buffer pointer physical address
$module [getQueueBufPointer] $in (queue_type: $uint<2> server_id: $uint<8>) $out (qptr : $uint<36>) $is
{
	base_idx := ($call getBaseIndex ( queue_type server_id))

	$call accessRegister (READMEM _hF (base_idx+4) $zero<32>) (qptr_h)
	$call accessRegister (READMEM _hF (base_idx+5) $zero<32>) (qptr_l)

	qptr := ($concat ($slice qptr_h 3 0) qptr_l)

	$attribute input_buffering 0
	$attribute output_buffering 0
}

//
// qptr is aligned to quad-word boundary.
//
$module [accessQueueTotalMsgs] 
	$in (rwbar: $uint<1> qptr: $uint<36> wdata: $uint<32>) $out (rdata: $uint<32>) $is
{
	$call accessMemoryDword (UNLOCKMEM rwbar _hF0 qptr ($concat wdata $zero<32>)) (dword)
	$volatile rdata := ($slice  dword 63 32)

	$attribute input_buffering 0
	$attribute output_buffering 0
}
$module [accessQueueReadIndex] 
	$in (rwbar: $uint<1> qptr: $uint<36> wdata: $uint<32>) $out (rdata: $uint<32>) $is
{
	$call accessMemoryDword (UNLOCKMEM rwbar _h0F qptr ($concat $zero<32> wdata)) (dword)
	$volatile rdata := ($slice  dword 31 0)

	$attribute input_buffering 0
	$attribute output_buffering 0
}
$module [accessQueueWriteIndex] 
	$in (rwbar: $uint<1> qptr: $uint<36> wdata: $uint<32>) $out (rdata: $uint<32>) $is
{
	$call accessMemoryDword (UNLOCKMEM rwbar _hF0 (qptr + 8) ($concat wdata $zero<32>)) (dword)
	$volatile rdata := ($slice  dword 63 32)

	$attribute input_buffering 0
	$attribute output_buffering 0
}
$module [accessQueueLength] 
	$in (rwbar: $uint<1> qptr: $uint<36> wdata: $uint<32>) $out (rdata: $uint<32>) $is
{
	$call accessMemoryDword (UNLOCKMEM rwbar _h0F (qptr + 8) ($concat $zero<32> wdata)) (dword)
	$volatile rdata := ($slice  dword 31 0)

	$attribute input_buffering 0
	$attribute output_buffering 0
}
$module [accessQueueMsgSizeInBytes] 
	$in (rwbar: $uint<1> qptr: $uint<36> wdata: $uint<32>) $out (rdata: $uint<32>) $is
{
	$call accessMemoryDword (UNLOCKMEM rwbar _hF0 (qptr + 16) ($concat wdata $zero<32>)) (dword)
	$volatile rdata := ($slice  dword 63 32)

	$attribute input_buffering 0
	$attribute output_buffering 0
}
$module [accessQueueMisc] 
	$in (rwbar: $uint<1> qptr: $uint<36> wdata: $uint<32>) $out (rdata: $uint<32>) $is
{
	$volatile addr := (qptr + ($bitcast ($uint<36>) 24))
	$call accessMemoryDword (UNLOCKMEM rwbar _h0F addr ($concat $zero<32> wdata)) (dword)
	$volatile rdata := ($slice  dword 31 0)

	$attribute input_buffering 0
	$attribute output_buffering 0
}
$module [accessQueueElement] 
	$in (rwbar: $uint<1> base_addr: $uint<36> index: $uint<32> wdata: $uint<32>) 
		$out (rdata: $uint<32>) $is
{
	// base + (4*index)
	$volatile addr := ($bitcast ($uint<36>) (base_addr + ($concat $zero<2> ($slice index 31 0) $zero<2>)))

	// set bottom bit of addr to 0 for u64 access.
	$volatile addr_u64 := ($concat ($slice addr 35 1) $zero<1>)

	$volatile low_word := (index [] 1)
	$volatile bmask    := ($mux low_word ($bitcast ($uint<8>) _h0F) ($bitcast ($uint<8>) _hF0))
	$volatile wdata64  := ($mux low_word ($concat $zero<32> wdata) ($concat wdata $zero<32>))

	$call accessMemoryDword (UNLOCKMEM rwbar bmask addr_u64 wdata64) (dword)
	$volatile rdata := ($mux low_word  ($slice dword 31 0) ($slice dword 63 32))

	$attribute input_buffering 0
	$attribute output_buffering 0
}


//
// Utilities
//    Pop a uint32_t from the queue.  Return status = 0 on success.
//
//	1. acquire lock
// 	2. Get read write indices
//	3. calculate next read index
//	4. read queue data
//	5. update queue indices
//	6. release lock
$module [popFromQueue]
	$in (queue_type: $uint<2> server_id : $uint<8>) $out (q_r_data: $uint<32> status: $uint<1>)
$is
{
	// get the physical address of the queue in memory.
	$call getQueuePointer (queue_type server_id) (q_base_address)

	// check if misc is 1,
	// if 1 check if total_msgs is 0
	//  if yes wait for total_msgs to be 1
	//   when 1 pop data
	// if misc is 0 
	// follow old method
	$call accessQueueMisc (READMEM q_base_address $zero<32>) (misc)

	//$branchblock[loop]
	//{
	//	$merge $entry loopback $endmerge
	//
	//	$call getTotalMessages(q_base_address) (total_msgsI)
	//	$volatile q_emptyI := (total_msgsI == 0)
	//
	//	$volatile misc_one := (misc == 1)
	//	$if(misc_one & q_emptyI) $then
	//		$place[loopback]
	//	$endif
	//}
	$volatile lock_n  := (misc == $zero<32>)

	// get lock pointer
	$guard (lock_n)
		$call getQueueLockPointer (queue_type server_id) (q_lock_address)

	// acquire lock.
	$guard (lock_n) 
		$call acquireLock(q_lock_address) (m_ok)

	$barrier
	
	// Read from the CORTOS2 data srtucture.
	$call getQueuePointers (q_base_address) (write_index read_index)
	$volatile q_empty := (write_index == read_index)

	$call getQueueLength(q_base_address) (queue_length)
	$call getTotalMessages(q_base_address) (total_msgs)

	$volatile round_off := (read_index == (queue_length - 1))
	$volatile next_ri   := ($mux round_off 0 (read_index + 1))
	
	// get buffer pointer  (PA stored in NIC)
	$guard (~q_empty) $call getQueueBufPointer (queue_type server_id) (q_buf_address)
	
	// From the CORTOS2 data structure.
	$guard (~q_empty) $call getQueueElement     (q_buf_address read_index) (q_r_data)

	$guard (~q_empty) $call setQueuePointers    (q_base_address write_index next_ri) ()
	$guard (~q_empty) $call updateTotalMessages (q_base_address (total_msgs - $one<32>)) ()

	$barrier

	$guard(lock_n) $call releaseLock (q_lock_address) ()
	status := q_empty // 0 = success, 1 = Fail
	
}

//
//
// Utilities
//    push a uint32_t into the queue.  Return status = 0 on success.
// 
//	1. acquire lock
// 	2. Get read write indexs
//	3. calculate next write index
//	4. write data to queue
//	5. update queue indexes
//	6. release lock
//
$module [pushIntoQueue] 
	$in  (queue_type: $uint<2> server_id: $uint<8> q_w_data: $uint<32>) $out (status: $uint<1>)
$is
{
	// check if misc is 1,
	// if 1 check if total_msgs is 1
	//  if yes wait for total_msgs to be 0
	//   when 0 push data
	// if misc is 0 
	// follow old method

	// get the physical address of the queue in memory.
	$call getQueuePointer (queue_type server_id) (q_base_address)

	$call accessMemoryDword (UNLOCKMEM READMEM  (~$zero<8>) (q_base_address + 24 ) $zero<64>) (ba_and_misc)
	$volatile misc := ($slice ba_and_misc 31 0)

	// if misc is 0, then acquire lock
	$volatile lock_n  := (misc == $zero<32>)

	$guard (lock_n)
		$call getQueueLockPointer (queue_type server_id) (q_lock_address)
	$guard (lock_n) 
		$call acquireLock (q_lock_address) (m_ok) 

	$barrier

	// access and manipulate cortos2 data structure
	$call getQueuePointers (q_base_address) (write_index read_index)
	$call getQueueLength(q_base_address) (queue_length)
	$call getTotalMessages(q_base_address) (total_msgs)
	$volatile round_off := (write_index == (queue_length - 1))
	$volatile next_wi := ($mux round_off 0 (write_index + 1))
	
	$volatile q_full := (next_wi == read_index)

	// get buffer pointer PA stored in NIC
	$guard (~q_full)
		$call getQueueBufPointer (queue_type server_id) (q_buf_address)

	// update the element in the queue buf.
	$guard (~q_full) $call setQueueElement  (q_buf_address write_index q_w_data) ()

	// update pointers, size in the queue struct.
	$guard (~q_full) $call setQueuePointers (q_base_address next_wi read_index) ()
	$guard (~q_full) $call updateTotalMessages (q_base_address (total_msgs + $one<32>)) ()


	$barrier
	$guard (lock_n) $call releaseLock (q_lock_address) ()
	status := (~q_full)
}

//
// to get queue length from the CORTOS2 data structure.
//
$module [getQueueLength]
	$in (q_base_address : $uint<36>) $out (queue_length : $uint<32>)
$is
{
	$call accessQueueLength (READMEM q_base_address $zero<32>) (queue_length)
}

//
// lock read  modify write (aka LDSTUB), spin till lock acquired.
//
//	1. read data at lock_pointer(address)
//	2. get 8bit lock data from 64bit read data
//	3. if lock = FF -> keep checking (release mem lock and acquire again)
//	     else set lock(queue) = FF aalong with releasing memory lock
$module [acquireLock] $in (lock_address_pointer_36: $uint<36>) $out (m_ok: $uint<1>) 
$is
{
	$branchblock[loop] {


		$merge $entry loopback $endmerge
		
		// read the lock (note that this is a locked read)
		$call accessMemoryByte (LOCKMEM READMEM  lock_address_pointer_36 $zero<8>) (lock_val)

		$if (lock_val == (~$zero<8>)) $then
			// unlock memory path
			$call accessMemoryByte 
				(UNLOCKMEM READMEM lock_address_pointer_36 $zero<8>) (ign_rval)
			$place [loopback]
		$endif

		// write 0xFF into lock location..  (also unlock the memory path).
		$call accessMemoryByte (UNLOCKMEM WRITEMEM lock_address_pointer_36 _hFF) (ignore)
	}

	m_ok := $one<1>
}


//
// set lock to 00000000 in queue.
//
//	1. read lock pointer from queue
//	2. create bmask(which will only update corresponding locks bits)
//	3. write 0 to lock address with bamsk.
$module [releaseLock] $in (lock_address_pointer_36: $uint<36>) $out () $is
{
		
	// write 0x0 into lock location..  (also unlock the memory path).
	$call accessMemoryByte 
		(UNLOCKMEM WRITEMEM lock_address_pointer_36 0) (ignore)
}

	

//
// get wp, rp pair from the CORTOS2 data structure.
//
$module [getQueuePointers] $in (q_base_address: $uint<36>)
		$out (wp rp: $uint<32>) $is
{
    $call accessQueueReadIndex  (READMEM q_base_address $zero<32>) (rp)
    $call accessQueueWriteIndex (READMEM q_base_address $zero<32>) (wp)
}

//
// set wp, rp pair in the CORTOS2 data structure.
//
$module [setQueuePointers] $in (q_base_address: $uint<36> wp rp: $uint<32>) $out ()  $is
{

    $rreport(setQueuePointers set q_base_address wp rp)

    $call accessQueueReadIndex  (WRITEMEM q_base_address rp) (ign_rp)
    $call accessQueueWriteIndex (WRITEMEM q_base_address wp) (ign_wp)
}

	
//
// get element pointed to by read-index
// inside queue.
//
$module  [getQueueElement]
	$in (buf_base_addr: $uint<36> read_index: $uint<32>) 
	$out (q_r_data : $uint<32>)
$is
{
	$call accessQueueElement  (READMEM buf_base_addr read_index $zero<32>) (q_r_data)
}

//
// set queue element pointed to by write
// index.
//
$module  [setQueueElement]
	$in (buf_base_address: $uint<36> write_index: $uint<32> q_w_data : $uint<32>)
	$out () 
$is
{
	$call accessQueueElement  (WRITEMEM buf_base_address write_index $zero<32>) (q_r_data)
}

// from the cortos2 data structure.
$module [getTotalMessages]
	$in (q_base_address : $uint<36>)
	$out(total_msgs : $uint<32>)
$is
{	
	$call accessQueueTotalMsgs (READMEM q_base_address $zero<32>) (total_msgs)
}

// to the cortos2 data structure.
$module [updateTotalMessages]
	$in (q_base_address : $uint<36> updated_total_msgs : $uint<32>)
	$out()
$is
{	
	$call accessQueueTotalMsgs (WRITEMEM q_base_address updated_total_msgs) (ignore)
}

