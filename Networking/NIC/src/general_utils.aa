//Delay Block
// Adds T number of clock cycles of delay
$operator $module [delay_time]
	$in (T: $uint<10>) $out (delay_done : $uint<1>) $is
{
	$branchblock[loop] {
	    $dopipeline $depth 7 $fullrate
		$merge $entry $loopback
			$phi R := T $on $entry nR $on $loopback
		$endmerge

		$volatile nR := (R - 1)
	   $while (R > 0)
	}
	delay_done := 1
}

// If the packet is a bad packet then, repurpose the buffer by pushing it back to Free Queue
$module [pushPointerBackToFreeQ]
	$in(pointer_to_push : $uint<36>) $out()
$is
{
	$branchblock[body] {
		$merge $entry unsuccessful_push_loopback
			// On Entry No waiting
			// If push is unsuccessful because of full Queue then wait for WAIT_TIME
			// and then retry
			$phi wait_req := $one<1> $on $entry
			    	($call delay_time (WAIT_TIME)) $on unsuccessful_push_loopback
		$endmerge

		// top 32 bits only..  pointer is quad-word aligned.
		$volatile q_w_data := ($slice pointer_to_push 35 4)

		// If wait period is over, then push data into the Queue
		$call pushIntoQueue (FREEQUEUE 0 ($slice pointer_to_push 35 4)) (push_status)
		
		// IF push is unsuccessful then wait for WAIT_TIME and retry
		$if(~push_status) $then
			$place [unsuccessful_push_loopback]
		$endif
	}
}
