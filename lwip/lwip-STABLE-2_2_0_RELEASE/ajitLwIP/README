Title : Porting LwIP for AJIT.
Author : Siddhant Singh Tomar
Date   : 12/1/2024

    1. include folder
        contains various configuration file for LwIP
            cc.h :
            sys_arch.h:
            lwipopts.h:
    2. src folder
        contains mainloop code for baremetal use of LwIP.




/* Following contains important functions and their descriptions */

    1.  struct pbuf *pbuf_alloc(pbuf_layer l, u16_t length, pbuf_type type);
    
            - First arg: Takes one of the following enum "pbuf_layer" literals,
                         before each literal, its description is given. 
                            typedef enum {

                            /** Includes spare room for transport layer header, e.g. UDP header.
                             * Use this if you intend to pass the pbuf to functions like udp_send().
                             */
                            PBUF_TRANSPORT = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN,

                            /** Includes spare room for IP header.
                             * Use this if you intend to pass the pbuf to functions like raw_send().
                             */
                            PBUF_IP = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN,

                            /** Includes spare room for link layer header (ethernet header).
                             * Use this if you intend to pass the pbuf to functions like ethernet_output().
                             * @see PBUF_LINK_HLEN
                             */
                            PBUF_LINK = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN,

                            /** Includes spare room for additional encapsulation header before ethernet
                             * headers (e.g. 802.11).
                             * Use this if you intend to pass the pbuf to functions like netif->linkoutput().
                             * @see PBUF_LINK_ENCAPSULATION_HLEN
                             */
                            PBUF_RAW_TX = PBUF_LINK_ENCAPSULATION_HLEN,

                            /** Use this for input packets in a netif driver when calling netif->input()
                             * in the most common case - ethernet-layer netif driver. */
                            PBUF_RAW = 0

                            } pbuf_layer;   
            
            - Second arg: Takes length of the packet including headers,
                          before each literal, its description is given.

            - Third arg : Takes one of the following enum "pbuf_layer" literal,
                          before each literal, its description is given.

                            typedef enum {
                            /** pbuf data is stored in RAM, used for TX mostly, struct pbuf and its payload
                                 are allocated in one piece of contiguous memory (so the first payload byte
                                can be calculated from struct pbuf).
                                pbuf_alloc() allocates PBUF_RAM pbufs as unchained pbufs (although that might
                                change in future versions).
                                This should be used for all OUTGOING packets (TX).*/
                            PBUF_RAM = (PBUF_ALLOC_FLAG_DATA_CONTIGUOUS | PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP),

                            /** pbuf data is stored in ROM, i.e. struct pbuf and its payload are located in
                                 totally different memory areas. Since it points to ROM, payload does not
                                have to be copied when queued for transmission. */
                            PBUF_ROM = PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF,

                            /** pbuf comes from the pbuf pool. Much like PBUF_ROM but payload might change
                                 so it has to be duplicated when queued before transmitting, depending on
                                who has a 'ref' to it. */
                            PBUF_REF = (PBUF_TYPE_FLAG_DATA_VOLATILE | PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF),

                            /** pbuf payload refers to RAM. This one comes from a pool and should be used
                                 for RX. Payload can be chained (scatter-gather RX) but like PBUF_RAM, struct
                                pbuf and its payload are allocated in one piece of contiguous memory (so
                                the first payload byte can be calculated from struct pbuf).
                                Don't use this for TX, if the pool becomes empty e.g. because of TCP queuing,
                                you are unable to receive TCP acks! */
                            PBUF_POOL = (PBUF_ALLOC_FLAG_RX | PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF_POOL)

                            } pbuf_type;



    2.  








/* Following contains important structures used in low level driver functions */

    1.  netif (as given in netif.h)

            /** Generic data structure used for all lwIP network interfaces.
             *  The following fields should be filled in by the initialization
             *  function for the device driver: hwaddr_len, hwaddr[], mtu, flags */
            struct netif {    
                
                /** This function is called by the network device driver
                 *  to pass a packet up the TCP/IP stack. */
                netif_input_fn input;

                /** This function is called by ethernet_output() when it wants
                 *  to send a packet on the interface. This function outputs
                 *  the pbuf as-is on the link medium. */
                netif_linkoutput_fn linkoutput;

                /** link level hardware address of this interface */
                u8_t hwaddr[NETIF_MAX_HWADDR_LEN];
                /** number of bytes used in hwaddr */
                u8_t hwaddr_len;
                /** flags (@see @ref netif_flags) */
                u8_t flags;
                /** descriptive abbreviation */
                char name[2];
                /** number of this interface. Used for @ref if_api and @ref netifapi_netif,
                 * as well as for IPv6 zones */
                u8_t num;
                /** maximum transfer unit (in bytes) */
                u16_t mtu;
                /** This field can be set by the device driver and could point
                 *  to state information for the device. */
                void *state;


                #if !LWIP_SINGLE_NETIF
                /** pointer to next in linked list */
                struct netif *next;
                #endif

                #if LWIP_IPV4
                /** IP address configuration in network byte order */
                ip_addr_t ip_addr;
                ip_addr_t netmask;
                ip_addr_t gw;
                #endif /* LWIP_IPV4 */
                #if LWIP_IPV6
                /** Array of IPv6 addresses for this netif. */
                ip_addr_t ip6_addr[LWIP_IPV6_NUM_ADDRESSES];
                /** The state of each IPv6 address (Tentative, Preferred, etc).
                 * @see ip6_addr.h */
                u8_t ip6_addr_state[LWIP_IPV6_NUM_ADDRESSES];
                #if LWIP_IPV6_ADDRESS_LIFETIMES
                /** Remaining valid and preferred lifetime of each IPv6 address, in seconds.
                 * For valid lifetimes, the special value of IP6_ADDR_LIFE_STATIC (0)
                 * indicates the address is static and has no lifetimes. */
                u32_t ip6_addr_valid_life[LWIP_IPV6_NUM_ADDRESSES];
                u32_t ip6_addr_pref_life[LWIP_IPV6_NUM_ADDRESSES];
                #endif /* LWIP_IPV6_ADDRESS_LIFETIMES */
                #endif /* LWIP_IPV6 */
                #if LWIP_IPV4
                /** This function is called by the IP module when it wants
                 *  to send a packet on the interface. This function typically
                 *  first resolves the hardware address, then sends the packet.
                 *  For ethernet physical layer, this is usually etharp_output() */
                netif_output_fn output;
                #endif /* LWIP_IPV4 */
                #if LWIP_IPV6
                /** This function is called by the IPv6 module when it wants
                 *  to send a packet on the interface. This function typically
                 *  first resolves the hardware address, then sends the packet.
                 *  For ethernet physical layer, this is usually ethip6_output() */
                netif_output_ip6_fn output_ip6;
                #endif /* LWIP_IPV6 */
                #if LWIP_NETIF_STATUS_CALLBACK
                /** This function is called when the netif state is set to up or down
                 */
                netif_status_callback_fn status_callback;
                #endif /* LWIP_NETIF_STATUS_CALLBACK */
                #if LWIP_NETIF_LINK_CALLBACK
                /** This function is called when the netif link is set to up or down
                 */
                netif_status_callback_fn link_callback;
                #endif /* LWIP_NETIF_LINK_CALLBACK */
                #if LWIP_NETIF_REMOVE_CALLBACK
                /** This function is called when the netif has been removed */
                netif_status_callback_fn remove_callback;
                #endif /* LWIP_NETIF_REMOVE_CALLBACK */
                #ifdef netif_get_client_data
                void* client_data[LWIP_NETIF_CLIENT_DATA_INDEX_MAX + LWIP_NUM_NETIF_CLIENT_DATA];
                #endif
                #if LWIP_NETIF_HOSTNAME
                /* the hostname for this netif, NULL is a valid value */
                const char*  hostname;
                #endif /* LWIP_NETIF_HOSTNAME */
                #if LWIP_CHECKSUM_CTRL_PER_NETIF
                u16_t chksum_flags;
                #endif /* LWIP_CHECKSUM_CTRL_PER_NETIF*/
                #if LWIP_IPV6 && LWIP_ND6_ALLOW_RA_UPDATES
                /** maximum transfer unit (in bytes), updated by RA */
                u16_t mtu6;
                #endif /* LWIP_IPV6 && LWIP_ND6_ALLOW_RA_UPDATES */
                #if LWIP_IPV6_AUTOCONFIG
                /** is this netif enabled for IPv6 autoconfiguration */
                u8_t ip6_autoconfig_enabled;
                #endif /* LWIP_IPV6_AUTOCONFIG */
                #if LWIP_IPV6_SEND_ROUTER_SOLICIT
                /** Number of Router Solicitation messages that remain to be sent. */
                u8_t rs_count;
                #endif /* LWIP_IPV6_SEND_ROUTER_SOLICIT */
                #if MIB2_STATS
                /** link type (from "snmp_ifType" enum from snmp_mib2.h) */
                u8_t link_type;
                /** (estimate) link speed */
                u32_t link_speed;
                /** timestamp at last change made (up/down) */
                u32_t ts;
                /** counters */
                struct stats_mib2_netif_ctrs mib2_counters;
                #endif /* MIB2_STATS */
                #if LWIP_IPV4 && LWIP_IGMP
                /** This function could be called to add or delete an entry in the multicast
                     filter table of the ethernet MAC.*/
                netif_igmp_mac_filter_fn igmp_mac_filter;
                #endif /* LWIP_IPV4 && LWIP_IGMP */
                #if LWIP_IPV6 && LWIP_IPV6_MLD
                /** This function could be called to add or delete an entry in the IPv6 multicast
                     filter table of the ethernet MAC. */
                netif_mld_mac_filter_fn mld_mac_filter;
                #endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
                #if LWIP_ACD
                struct acd *acd_list;
                #endif /* LWIP_ACD */
                #if LWIP_NETIF_USE_HINTS
                struct netif_hint *hints;
                #endif /* LWIP_NETIF_USE_HINTS */
                #if ENABLE_LOOPBACK
                /* List of packets to be queued for ourselves. */
                struct pbuf *loop_first;
                struct pbuf *loop_last;
                #if LWIP_LOOPBACK_MAX_PBUFS
                u16_t loop_cnt_current;
                #endif /* LWIP_LOOPBACK_MAX_PBUFS */
                #if LWIP_NETIF_LOOPBACK_MULTITHREADING
                /* Used if the original scheduling failed. */
                u8_t reschedule_poll;
                #endif /* LWIP_NETIF_LOOPBACK_MULTITHREADING */
                #endif /* ENABLE_LOOPBACK */
            };



    2.  eth_addr and eth_hdr (as given in ethernet.h)

           
                /** An Ethernet MAC address */
                struct eth_addr {
                PACK_STRUCT_FLD_8(u8_t addr[ETH_HWADDR_LEN]);
                } PACK_STRUCT_STRUCT;
           

                /** Ethernet header */
                struct eth_hdr {
                #if ETH_PAD_SIZE
                PACK_STRUCT_FLD_8(u8_t padding[ETH_PAD_SIZE]);
                #endif
                PACK_STRUCT_FLD_S(struct eth_addr dest);
                PACK_STRUCT_FLD_S(struct eth_addr src);
                PACK_STRUCT_FIELD(u16_t type);
                } PACK_STRUCT_STRUCT;
          



/* Following tables contains options changed 
and files in which they are changed */

Options         Value   File    

ETH_PAD_SIZE    2       opt.h
